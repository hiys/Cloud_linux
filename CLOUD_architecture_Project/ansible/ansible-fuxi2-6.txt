
http://www.yaml.org

yaml:     # 使用了双引号，双引号的好处是可以转义，即在里面可以使用特殊符号
     #可以使用双引号或者单引号包裹特殊字符
scalar
英 [ˈskeɪlə(r)]   美 [ˈskelɚ, -ˌlɑr]  
adj.
标量的;梯状的;分等级的;数量的
n.
数量，标量

string:
    - 哈哈
    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符

YAML 数据由以下三种结构组成：（每个文档由三种结构混合组成）

标量 （相当于数据类型）

序列 （相当于数组和列表）

键值表（相当于 Map 表）

 禁止 使用 tab 缩进 ，只能使用  空格 键
[ 注意有些编辑器会自动把空格转换成 tab,一定要选择不能自动转换tab的编辑器 ]

缩进长度  没有 限制，只要元素 对齐 就 表示 这些元素属于一个层级。

层级关系 除了使用 缩进，还能够使用 特定 符号 来表示。

– 同一 层级 缩进 必须对齐

– YAML使用一个 固定的 缩进风格 表示 数据 层级 结构关系
– 一般每个 缩进 级别 由 两个 以上 空格 组成

– # 表示注释

层级关系 除了使用 缩进，还能够使用 特定 符号 来表示。

YAML中提供了很多特殊符号，在这里简单介绍常用的一些：
1，---  YAML可以在同一个文件中，使用---表示一个文档的开始

server:
    address: 192.168.1.100
---  # 表示一个文档的开始
spring:
    profiles: development
    server:
        address: 127.0.0.1
...  # 代表一个文件的结束
---
spring:
    profiles: production
    server:
        address: 192.168.1.120

代表定义了两个profile，一个是development，一个production；也常常使用---来分割不同的内容

2，... 和---配合使用，在一个配置文件中代表一个文件的结束：
--- 代表一个文件的开始
time: 20:03:20
player: Sammy Sosa
action: strike (miss)
...
---  # 表示一个文档的开始
time: 20:03:47
player: Sammy Sosa
action: grand slam
...  # 代表一个文件的结束
相当于在一个yaml文件中连续写了两个yaml配置项。

如果只是单个文档，分隔符“---”可省略。

每个文档并不需要使用结束符“...”来表示结束，
但是对于网络传输或者流来说，作为明确结束的符号，有利于软件处理。


层级关系 除了使用 缩进，还能够使用 特定 符号 来表示。

– 同一 层级 缩进 必须对齐

 | 符号保留了换行符
 | 符号常见用于在YAML中配置 HTML 片段：

phraseTemplate: |
  <p style="color: red">
    some template ${msg}
  </p>

 >在字符串中折叠换行，
 | 保留换行符，
这两个符号是YAML中字符串经常使用的符号

 引用。
重复的内容在YAML中可以使用&来完成锚点定义，
使用*来完成锚点引用，
例如：
hr:
- Mark McGwire
- &SS Sammy Sosa
rbi:
- *SS 
- Ken Griffey

可以看到，在hr中，使用 &SS 为 Sammy Sosa 设置了一个锚点（引用），名称为SS，
          在rbi中，使用*SS完成了锚点使用，
那么结果为：
{rbi=[Sammy Sosa, Ken Griffey], hr=[Mark McGwire, Sammy Sosa]}

 #下面是内置类型
 !!int               # 整数类型
 !!float             # 浮点类型
 !!bool              # 布尔类型
 !!str               # 字符串类型
 !!binary            # 也是字符串类型
 !!timestamp         # 日期时间类型
 !!null              # 空值
 !!set               # 集合
 !!omap, !!pairs     # 键值列表或对象列表
 !!seq               # 序列，也是列表
 !!map               # 键值表

常用数据类型的 约定 表示格式 
 integer: 12345     # 整数标准形式
 octal: 0o34        # 八进制表示，第二个是字母 o
 hex: 0xFF          # 十六进制表示
 
 float: 1.23e+3     # 浮点数
 fixed: 13.67       # 固定小数
 minmin: -.inf      # 表示负无穷
 notNumber: .NaN    # 无效数字
 
 null:              # 空值
 boolean: [true, false] # 布尔值
 string: ‘12345‘    # 字符串
 
 date: 2015-08-23   # 日期
 datetime: 2015-08-23T02:02:00.1z  # 日期时间
 iso8601: 2015-08-23t21:59:43.10-05:00  # iso8601 日期格式
 spaced: 2015-08-23 21:59:43.10 -5      # ?
“!”（叹号）显式指示类型，或自定义类型标识。单叹号通常是自定义类型，双叹号是内置类型

 isString: !!str 2015-08-23     # 强调是字符串不是日期数据

块级列表 使用 短横线 和 空格 开头，如 "- "
– 数组   使用 "- " 来表示
– 键值对 使用 ": " 来表示
键值对 使用 冒号 和 空格 来隔开 键和值，如 "key: value"

# 使用了双引号，双引号的好处是可以转义，即在里面可以使用特殊符号
     #可以使用双引号或者单引号包裹特殊字符
字符串可以 不用 引号 标注

– 同一个列表中的元素应该保持相同的缩进
缩进长度  没有 限制，只要元素 对齐 就 表示 这些元素属于一个层级

在该项下面缩进空格来表示层级关系

"键": "值"  # 注意在 "值"的前面 缩进 1 个空格

或者 这样表示

"键":   # 注意直接敲 回车符号换行
  "值"  # 注意头部对齐 缩进 2 个空格

"键-数组名":        # 注意直接敲 回车符号换行
  - "值-数组元素1"  # 注意头部对齐 缩进 2 个空格,短横杠 后 一个 空格
  - "值-数组元素2"  # 注意头部对齐 缩进 2 个空格,短横杠 后 一个 空格
  - "值-数组元素3"  # 注意头部对齐 缩进 2 个空格,短横杠 后 一个 空格

数组也可以采用行内表示法
数组名: [数组元素1, 数组元素2, 数组元素3] 
   ##注意 逗号, 和冒号: 后面的 空格,键值对 使用 冒号 和 空格 来隔开 键和值

============注意 yaml 分隔符没有逗号,  YAML 是一种简洁的非标记语言================

---                  #  ---代表一个文件的开始
"父键-父数组名key":        # 注意直接敲 回车符号换行
  -                     # 注意头部对齐 缩进 2 个空格, 短横杠 - 后面直接敲 回车符号换行[ 下面的都是子数组 ]
    "子键a": "子值a"  # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
    "子键b-子数组名1":         # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
      - "子值b-子数组元素b1"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值b-子数组元素b2"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值b-子数组元素b3"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
  -                     # 注意头部对齐 缩进 2 个空格, 短横杠 - 后面直接敲 回车符号换行[ 下面的都是子数组 ]
    "子键c": "子值c"  # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
    "子键d-子数组名2":         # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
      - "子值d-子数组元素d1"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值d-子数组元素d2"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值d-子数组元素d3"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
  -                     # 注意头部对齐 缩进 2 个空格, 短横杠 - 后面直接敲 回车符号换行[ 下面的都是子数组 ]
    "子键e": "子值e"  # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
    "子键f-子数组名3":         # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
      - "子值f-子数组元素f1"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值f-子数组元素f2"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值f-子数组元素f3"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
...           # ...代表一个文件的结束
---
父键父数组名key:
  -
    子键a: 子值a
    子键b子数组名1:
      - 子值b子数组元素b1
      - 子值b子数组元素b2
      - 子值b子数组元素b3
  -
    子键c: 子值c
    子键d-子数组名2:
      - 子值d子数组元素d1
      - 子值d子数组元素d2
      - 子值d子数组元素d3
  -
    子键e: 子值e
    子键f子数组名3:
      - 子值f子数组元素f1
      - 子值f子数组元素f2
      - 子值f子数组元素f3

数组也可以使用流式(flow)的方式表示：
companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]

父键父数组名key: [{子键a: 子值a, 子键b子数组名1: [子值b子数组元素b1, 子值b子数组元素b2, 子值b子数组元素b3]}, {子键c: 子值c, 子键d子数组名2: [子值d子数组元素d1, 子值d子数组元素d2, 子值d子数组元素d3]}, {子键e: 子值e, 子键f子数组名3: [子值f子数组元素f1, 子值f子数组元素f2, 子值f子数组元素f3]}]

数组也可以使用流式(flow)的方式表示：

key: [{a: a, b1: [bb1, bb2, bb3]}, {c: c, d2: [dd1, dd2, dd3]}, {e: e, f3: [ff1, ff2, ff3]}]
  
 ##注意逗号和冒号后面必须有一个空格,yaml语言格式

/*********json  格式  注意 json 分隔符 有 逗号, ******************
{ "键": [  { "键": "值",  "键": "值" }, {  "键": "值",  "键": "值"} ]
}

{ "键1": [  { "键a": "值a",  "键b": "值b" }, {  "键c": "值c",  "键"d: "值d"} ],
  "键2": [  { "键a": "值a",  "键b": "值b" }, {  "键c": "值c",  "键"d: "值d"} ],
  "键3": [  { "键e": "值e",  "键f": "值f" }, {  "键g": "值g",  "键h": "值h"} ]
}

大括号{} 表示对象, 用 点号 . 来引用 对象的 .属性/或函数 .(函数后面要加小括号)... 
中括号[] 表示数组, 用['下标']的方式来引用. 即使是混合式的数据结构, 也是同样的道理.
json的数据, 都是用 双引号, 
不管是key, 还是 value, 都要用 双引号 表示....
*************/

Jinja2是基于python的模板引擎，
功能比较类似于于PHP的smarty，
J2ee的Freemarker和velocity。
 它能完全支持unicode，
并具有集成的沙箱执行环境，应用广泛。
jinja2使用BSD授权。

特性编辑
沙箱执行模式，模板的每个部分都在引擎的监督之下执行，
模板将会被明确地标记在白名单或黑名单内，
这样对于那些不信任的模板也可以执行。

强大的自动HTML转义系统，可以有效地阻止跨站脚本攻击。

模板继承机制，此机制可以使得所有的模板都具有相似一致的布局，
也方便了开发人员对模板的修改和管理。

高效的执行效率，
Jinja2引擎在模板第一次加载时就把源码转换成Python字节码，加快模板执行时间。

可选的预编译模式。
调试系统融合了标准的Python的TrackBack系统，使得模板编译和运行期间的错误能及时被发现和调试。

语法可配置，可以重新配置Jinja2使得它更好地适应LaTeX或JavaScript的输出。
模板设计人员帮助手册，此手册指导设计人员更好地使用Jinja2引擎的各种方法。 


Jinja2语法：

字面量：
    字符串：使用单引号或双引号； 
    数字：整数、浮点数；
    列表：[item1, item2, ...]
    元组：(item1, item2, ...)
    字典：{key1:value1, key2:value2, ...}
    布尔型：true/false

算术运算：
    +, -, *, /, //, %, **

比较操作：
    ==, !=, >, <, >=, <=

逻辑运算：and, or, not
运算符

+号运算符：可以完成数字相加，字符串相加，列表相加。
但是并不推荐使用+运算符来操作字符串，字符串相加应该使用~运算符。

-号运算符：只能针对两个数字相减。
/号运算符：对两个数进行相除。
%号运算符：取余运算。
*号运算符：乘号运算符，并且可以对字符进行相乘。

**号运算符：次幂运算符，比如2**3=8。

###判断真假 
in操作符：跟python中的in一样使用，比如{{1 in [1,2,3]}}返回true。

~号运算符：拼接多个字符串，比如{{"Hello" ~ "World"}}将返回HelloWorld。

 {{variablename}}  ##调用变量 ##shell中 使用 ${var} 调用变量 

 {{3+8}}            ##计算  ##shell中 使用 $((3+8))

{{1  in  [1,2,3,4]}}   ##判断真假  ##shell中 没有类似的语法

/*************shell *************
使用expr来进行数字运算时，
不支持浮点类型的数字计算，
也不支持 带符号+ 的运算，
支持整数运算（包括 带符号 - 的运算）。
注意 expr 后面的变量 与命令expr 之间及变量与运算符之间必须使用空格隔开。

此处的引号为ESC下方的按键，不是通常的单引号。
echo  `expr  $a + ${b}`
echo  $((3+8))
采用中括号与小括号没有很大的差异，只是书写方式不一样
echo  $[a+b]
let命令来进行算术运算与小括号及中括号无较大差异，仅存在书写差异

[root@Va1 ~]# a=3;b=8;echo  `expr  $a  +  ${b}`
11
[root@Va1 ~]# echo  $((a+b))
11
[root@Va1 ~]# echo  $[a+b]
11
[root@Va1 ~]# let x=a+b;echo  ${x}
11
[root@Va1 ~]# echo  "scale=2;${a}*10.11+$b" |bc
38.33
**********/
{{ ... }}：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。
  模板的表达式 都是包含在分隔符{{ }}内的

{% ... %}：装载一个控制语句。
{# ... #}：装载一个注释，模板渲染的时候会忽视这中间的值

###判断真假 
in操作符：跟python中的in一样使用，比如{{1 in [1,2,3]}}返回true。

下表列出jinja2部分的常用过滤器

过滤器	说明
safe	渲染时不转义
capitalize	把值的首字母转换成大写，其他字母转换成小写
lower	把值转换成小写形式
upper	把值转换成大写形式
title	把值中每个单词的首字母都转换成大写
trim	把值的首尾空格去掉
striptags	渲染前把值中所有的HTML标签都删掉

自定义过滤器
 自定义过滤器的过程其实就是写一个函数，
这个函数至少有一个参数作为被过滤的内容，
即竖线左边的变量，其他的参数则需要传入
模板设计者文档
http://docs.jinkan.org/docs/jinja2/templates.html

http://docs.jinkan.org/docs/jinja2/
Jinja2 文档
介绍
预备知识
安装
基本 API 使用
实验性的 Python 3 支持
API
基础
...........
全局命名空间
低层 API
元 API

沙箱
API
运算符拦截

模板设计者文档
http://docs.jinkan.org/docs/jinja2/templates.html

概要
变量
过滤器
.............
表达式
内置过滤器清单
内置测试清单
全局函数清单
.............
Babel 集成
Pylons
TextMate
Vim
从其它的模板引擎切换
Jinja1
Django
Mako
提示和技巧
Null-Master 退回
交替的行
高亮活动菜单项
访问父级循环
...........
http://docs.jinkan.org/docs/jinja2/templates.html

 Jinja2是基于python的模板引擎，
功能比较类似于于PHP的smarty，
J2ee的Freemarker和velocity。
 它能完全支持unicode，
并具有集成的沙箱执行环境，应用广泛。
jinja2使用BSD授权。

特性编辑
沙箱执行模式，模板的每个部分都在引擎的监督之下执行，
模板将会被明确地标记在白名单或黑名单内，
这样对于那些不信任的模板也可以执行。

强大的自动HTML转义系统，可以有效地阻止跨站脚本攻击。

模板继承机制，此机制可以使得所有的模板都具有相似一致的布局，
也方便了开发人员对模板的修改和管理。

高效的执行效率，
Jinja2引擎在模板第一次加载时就把源码转换成Python字节码，加快模板执行时间。

可选的预编译模式。
调试系统融合了标准的Python的TrackBack系统，使得模板编译和运行期间的错误能及时被发现和调试。

语法可配置，可以重新配置Jinja2使得它更好地适应LaTeX或JavaScript的输出。
模板设计人员帮助手册，此手册指导设计人员更好地使用Jinja2引擎的各种方法。 

http://docs.jinkan.org/docs/jinja2/templates.html#builtin-tests

过滤器
变量可以通过 过滤器 修改。过滤器与变量用管道符号（ | ）分割，并且也 可以用圆括号传递可选参数。
多个过滤器可以链式调用，前一个过滤器的输出会被作为 后一个过滤器的输入。

例如 {{ name|striptags|title }}
 会移除 name 中的所有 HTML 标签并且改写 为标题样式的大小写格式。
过滤器接受带圆括号的参数，如同函数调用。
这个例子会 把一个列表用逗号连接起来: {{ list|join(', ') }} 。

测试可以用于对照普通表达式测试一个变量。 
要测试一个变量或表达式，你要在变量后加上一个 is 以及测试的名称。
例如，要得出 一个值是否定义过，
你可以用 name is defined ，这会根据 name 是否定义返回 true 或 false 。

测试也可以接受参数。
如果测试只接受一个参数，你可以省去括号来分组它们。
divisible 英 [dɪˈvɪzəbl]   美 [dɪˈvɪzəbəl]  
        adj. 可分开的，可除尽的

例如， 下面的两个表达式做同样的事情:
{% if loop.index is divisibleby 3 %}
{% if loop.index is divisibleby(3) %}

下面的 内置过滤器清单 节介绍了所有的内置过滤器。

abs(number)
返回参数的绝对值

attr(obj, name)
获取对象的属性。foo|attr（“bar”）的工作方式与foo[“bar”]类似，
只是始终返回一个属性，而不查找项。

folio   英 [ˈfəʊliəʊ]   美 [ˈfoʊlioʊ]  
n. 对开的纸，（原稿的）一页，页码或张数
adj. 对折的，对开的 vt. 编页码

[folio]∶印刷上指相当于整张纸的一半（整张纸的二分之一）

batch(value, linecount, fill_with=None)
批处理（值、行计数、填充为无）
批处理项目的筛选器。它的工作原理和切片很像，只是反过来。
它返回具有给定项数的列表列表。
如果提供第二个参数，则用于填充缺少的项。请参见此示例：
<table>
{%- for row in items|batch(3, '&nbsp;') %}
  <tr>
  {%- for column in row %}
    <td>{{ column }}</td>
  {%- endfor %}
  </tr>
{%- endfor %}
</table>

Jinja2是基于python的模板引擎，
功能比较类似于于PHP的smarty，
J2ee的Freemarker和velocity。
 它能完全支持unicode，
并具有集成的沙箱执行环境，应用广泛。
jinja2使用BSD授权。

play 
游戏;比赛;戏剧;赌博
vt.& vi.
玩;演奏;演出;参加比赛
vt.
扮演;担任，充当…的角色;演出;装扮
vi.
玩耍，游戏;[游戏] 参加游戏;赌博;闹着玩

playbook语法基础
• playbook 语法格式
– playbook由 YAML 语言编写,遵循 YAML 标准

– 在同一行中,#之后的内容表示注释
– 同一个列表中的元素应该保持相同的缩进
– playbook 由一个或多个 play 组成
– play 中 hosts,variables,roles,tasks 等对象的表示
方法都是键值中间以 ": " 分隔表示
– YAML 还有一个小的怪癖. 所有的 YAML 文件开始行都
应该是 ---. 这是 YAML 格式的一部分, 表明一个文件的开始

Playbook 简介 
playbook是ansible用于配置，部署和管理托管主机剧本，
通过playbook的详细描述，执行其中的一系列tasks，可以让远端主机达到预期状态

Playbooks与Ad-Hoc相比，是一种完全不同的运用Ansible的方式，而且是非常之强大的；
也是系统ansible命令的集合，其利用yaml语言编写，
运行过程，ansbile-playbook命令根据自上而下的顺序依次执行。
 
简单来说，Playbooks 是一种简单的配置管理系统与多机器部署系统的基础。
与现有的其他系统有不同之处，且非常适合于复杂应用的部署。 
同时，Playbooks开创了很多特性，
它可以允许你传输某个命令的状态到后面的指令，
如你可以从一台机器的文件中抓取内容并附为变量，然后在另一台机器中使用，
这使得你可以实现一些复杂的部署机制，这是ansible命令无法实现的。
 
Playbooks可用于声明配置，更强大的地方在于，
在Playbooks中可以编排有序的执行过程，甚至于做到在多组机器间，来回有序的执行特别指定的步骤。
并且可以同步或异步的发起任务。
 
我们使用Ad-Hoc时，主要是使用 /usr/bin/ansible 程序执行任务.

而使用Playbooks时，更多是将之放入源码控制之中，

ansible有两种工作模式pull/push ，默认使用push(推，推动)模式工作(主动模式)，

用之推送(push 推，推动) 你的配置或是用于确认你的远程系统的配置是否符合配置规范。 

在如右的链接中：ansible-examples repository，有一些整套的Playbooks，它们阐明了上述的这些技巧。

二、Playbook 构成 
Playbook主要有以下四部分构成： 
1. target section：定义将要执行playbook的远程主机组 
2. variable section：定义playbook运行时需要使用的变量 

3. task section：定义将要在远程主机上执行的任务列表 

4. handler section：定义task执行完成以后需要调用的任务

而Playbook对应的目录层有五个，分别如下： 
一般所需的目录层有：(视情况可变化) 
1. vars 变量层 
2. tasks 任务层 
3. handlers 触发条件 
4. files 文件 
5. template 模板 

structure
英 [ˈstrʌktʃə(r)]   美 [ˈstrʌktʃɚ]  
n. 结构;构造;建筑物;体系
vt. 构成，排列;安排

YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。

其结构（Structure）通过空格来展示，

序列（Sequence）里的项用”-“来代表，

Map里的键值对用”:”分隔。

下面是一个示例。

- hosts: 10.1.0.1        #定义主机
      vars:                      #定义变量
           var1: value
           var2: value
      tasks:                    #定义任务
           - name:           #任务名称。
       #这里就可以开始用模块来执行具体的任务了。

      handlers:     #定义触发通知所作的操作。里面也是跟tasks一样，用模块定义任务。
           - name:

      remote_user:             #远程主机执行任务时的用户。一般都是root，一般也不用指定。

    - hosts: web
      vars:
      tasks:
      handlers:
      remote_user:
YAML文件扩展名通常为.yaml，如example.yaml
https://blog.csdn.net/qq_32642039/article/details/81559728


ansible-pull:Ansible的另一种工作模式，pull模式(被动模式)，

ansible默认使用push模式(主动模式)；

ansible有两种工作模式pull/push ，默认使用push模式工作(主动模式)，
pull和push工作模式机制刚好相反
 
一般2000台主机以下 适用主动服务模式
2000台主机以上适用 被 动服务模式

push  推，推动

pull 拉;扯;拉过来;划（船）

使用ansible-playbook  运行playbook文件,
执行结果 输出 内容格式 json格式
不同颜色,如
绿色 代表执行成功
*** 代表 系统状态发生改变
红色代表 执行失败

---
父键父数组名key:
  -
    子键a: 子值a
    子键b子数组名1:
      - 子值b子数组元素b1
      - 子值b子数组元素b2
      - 子值b子数组元素b3
  -
    子键c: 子值c
    子键d-子数组名2:
      - 子值d子数组元素d1
      - 子值d子数组元素d2
      - 子值d子数组元素d3
  -
    子键e: 子值e
    子键f子数组名3:
      - 子值f子数组元素f1
      - 子值f子数组元素f2
      - 子值f子数组元素f3

数组也可以使用流式(flow)的方式表示：
companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]

父键父数组名key: [{子键a: 子值a, 子键b子数组名1: [子值b子数组元素b1, 子值b子数组元素b2, 子值b子数组元素b3]}, {子键c: 子值c, 子键d子数组名2: [子值d子数组元素d1, 子值d子数组元素d2, 子值d子数组元素d3]}, {子键e: 子值e, 子键f子数组名3: [子值f子数组元素f1, 子值f子数组元素f2, 子值f子数组元素f3]}]

数组也可以使用流式(flow)的方式表示：

key: [{a: a, b1: [bb1, bb2, bb3]}, {c: c, d2: [dd1, dd2, dd3]}, {e: e, f3: [ff1, ff2, ff3]}]
  
 ##注意逗号和冒号后面必须有一个空格,yaml语言格式

============注意 yaml 分隔符没有逗号,  YAML 是一种简洁的非标记语言================

---                  #  ---代表一个文件的开始
"父键-父数组名key":        # 注意直接敲 回车符号换行
  -                     # 注意头部对齐 缩进 2 个空格, 短横杠 - 后面直接敲 回车符号换行[ 下面的都是子数组 ]
    "子键a": "子值a"  # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
    "子键b-子数组名1":         # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
      - "子值b-子数组元素b1"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值b-子数组元素b2"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值b-子数组元素b3"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
  -                     # 注意头部对齐 缩进 2 个空格, 短横杠 - 后面直接敲 回车符号换行[ 下面的都是子数组 ]
    "子键c": "子值c"  # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
    "子键d-子数组名2":         # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
      - "子值d-子数组元素d1"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值d-子数组元素d2"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值d-子数组元素d3"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
  -                     # 注意头部对齐 缩进 2 个空格, 短横杠 - 后面直接敲 回车符号换行[ 下面的都是子数组 ]
    "子键e": "子值e"  # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
    "子键f-子数组名3":         # 注意头部对齐 缩进 4 个空格, 直接敲 回车符号换行
      - "子值f-子数组元素f1"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值f-子数组元素f2"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
      - "子值f-子数组元素f3"  # 注意头部对齐 缩进 6 个空格,短横杠 后 一个 空格
...           # ...代表一个文件的结束


key: [{a: a, b1: [bb1, bb2, bb3]}, {c: c, d2: [dd1, dd2, dd3]}, {e: e, f3: [ff1, ff2, ff3]}]
  

[root@Va1 ~]# vim  ping.yml
[root@Va1 ~]# cat  ping.yml

---                   #  ---代表一个文件的开始
- hosts: Va2       # 注意头部对齐 ,无缩进, 短横杠- 和 冒号:  后 一个 空格
  remote_user: root  ## # 注意头部对齐 缩进 2 个空格
  tasks:          # # # 注意头部对齐 缩进 2 个空格
    - ping:      # # # 注意头部对齐 缩进 4 个空格,短横杠 后 一个 空格

/**************
使用ansible-playbook  运行playbook文件,
执行结果 输出 内容格式 json格式
不同颜色,如
绿色 代表执行成功
*** 代表 系统状态发生改变
红色代表 执行失败

[root@Va1 ~]# ansible-playbook  ping.yml  #绿色 代表执行成功

PLAY [Va2] *********************************************************************

TASK [Gathering Facts] *********************************************************
ok: [Va2]

TASK [ping] ********************************************************************
ok: [Va2]

PLAY RECAP *********************************************************************
Va2                        : ok=2    changed=0    unreachable=0    failed=0   

[root@Va1 ~]# ll  ping.yml
-rw-r--r-- 1 root root 58 1月   9 21:23 ping.yml
[root@Va1 ~]# cat  ping.yml
---
- hosts: Va2
  remote_user: root
  tasks:
    - ping:
[root@Va1 ~]# 

http://docs.jinkan.org/docs/jinja2/templates.html#builtin-tests

[root@Va1 ~]# cat  apache.yaml 
# apache.yaml
---
- hosts: web
  remote_user: root
  tasks:
    - name: tasks-zi-listname install the specific  version of Apache
      yum:
        name: httpd
        state: present
    - lineinfile:
        path: /etc/httpd/conf/httpd.conf
        regexp: "^Listen "
        insertafter: "^Listen "
        line: "Listen  8080"
    - lineinfile:
        path: /etc/httpd/conf/httpd.conf
        regexp: "^#ServerName "
        insertbefore: "^#ServerName "
        line: "ServerName  localhost"
    - copy:
        src: /root/index.html
        dest: /var/www/html/index.html
        backup: yes
        owner: apache
        group: apache
        mode: 0644
    - service:
        name: httpd
        state: started
        enabled: yes
[root@Va1 ~]# 







